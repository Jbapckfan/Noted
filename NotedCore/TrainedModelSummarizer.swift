import Foundation
import CoreML

/// Use YOUR trained model for medical summarization
/// This model was trained on YOUR transcript-summary pairs
@MainActor
class TrainedModelSummarizer: ObservableObject {
    static let shared = TrainedModelSummarizer()

    private var model: MedicalSummarizer?
    @Published var isModelLoaded = false

    private init() {
        loadModel()
    }

    private func loadModel() {
        do {
            let config = MLModelConfiguration()
            config.computeUnits = .all // Use Neural Engine + GPU + CPU

            model = try MedicalSummarizer(configuration: config)
            isModelLoaded = true

            print("✅ Trained medical summarization model loaded")
            print("🧠 Using Neural Engine for on-device inference")

        } catch {
            print("❌ Failed to load trained model: \(error)")
            print("💡 Falling back to pattern-based summarization")
        }
    }

    /// Generate summary using YOUR trained model
    func generateSummary(from transcript: String) async -> String {
        guard let model = model else {
            return fallbackSummarization(transcript)
        }

        do {
            // Prepare input
            let input = MedicalSummarizerInput(text: transcript)

            // Run inference on Neural Engine
            let prediction = try model.prediction(input: input)

            // Get output (CoreML generates 'label' property for text classifiers)
            let summary = prediction.label

            print("✅ Generated summary using trained model")
            return formatSummary(summary)

        } catch {
            print("❌ Prediction failed: \(error)")
            return fallbackSummarization(transcript)
        }
    }

    private func formatSummary(_ rawSummary: String) -> String {
        // Add header and footer
        return """
        \(rawSummary)

        ---
        📱 Generated by YOUR trained model (100% offline)
        🧠 Apple Neural Engine - No internet required
        """
    }

    private func fallbackSummarization(_ transcript: String) -> String {
        // Simple fallback if model fails
        let sentences = transcript.components(separatedBy: CharacterSet(charactersIn: ".!?"))
            .filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }

        guard !sentences.isEmpty else {
            return "Insufficient transcript for summarization"
        }

        return """
        **SUMMARY:**

        \(sentences.prefix(5).joined(separator: ". ")).

        **Note:** Using fallback summarization. Train model with more samples for better results.
        """
    }
}

// MARK: - Integration with MedicalAIService

extension MedicalAIService {
    /// Generate summary using trained model (best for offline)
    func generateWithTrainedModel(conversation: ConversationAnalysis, noteType: NoteType) async -> String {
        let fullTranscript = """
        Chief Complaint: \(conversation.chiefComplaint)

        Transcript:
        \(conversation.originalText)

        Medical History: \(conversation.medicalHistory.joined(separator: ", "))
        Medications: \(conversation.medications.joined(separator: ", "))
        """

        let summary = await TrainedModelSummarizer.shared.generateSummary(from: fullTranscript)

        return """
        **\(noteType.rawValue.uppercased())**

        \(summary)

        Generated: \(Date().formatted())
        """
    }
}